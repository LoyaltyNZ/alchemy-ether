<!DOCTYPE html>

<html>
<head>
  <title>Alchemy Service</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="alchemy-service">Alchemy Service</h1>
<p>The main class of Alchemy-Ether is <code>Service</code>.
This implements all the functions necessary for sending, receiving and processing messages.
It uses a <code>ServiceConnectionManager</code> which is state driven to manage the connection between the service and RabbitMQ.</p>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="imports">Imports</h2>
<ul>
<li><code>bluebird</code> is the promises library</li>
<li><code>msgpack</code> is used to compress the sent messages</li>
<li><code>uuid</code> is used to generate unique IDs</li>
<li><code>amqp</code> is used to connect to RabbitMQ</li>
<li><code>lodash</code> is used as a general purpose utility library</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>bb = <span class="hljs-built_in">require</span> <span class="hljs-string">"bluebird"</span>
msgpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'msgpack'</span>)
uuid = <span class="hljs-built_in">require</span> <span class="hljs-string">'node-uuid'</span>
amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">"amqplib"</span>)
_ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="service">Service</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The service class is the primary class used when creating an Alchemy Service</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29">Version 4</a> UUIDS are used for identifiers in the Alchemy framework.
These are generated by the <a href="https://www.npmjs.com/package/node-uuid">node-uuid</a> package, and the <code>-</code>‘s removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  @generateUUID: <span class="hljs-function">-&gt;</span> uuid.v4().replace(<span class="hljs-regexp">/-/g</span>,<span class="hljs-string">''</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A <code>Service</code> is constructed with a required <code>name</code> (e.g. <code>B</code>) and a map of options:</p>
<ul>
<li><code>amqp_uri</code>: URI to RabbitMQ (default <code>&#39;amqp://localhost&#39;</code>)</li>
<li><code>service_queue</code>: create a service queue (default <code>true</code>)</li>
<li><code>response_queue</code>: create a response queue (default <code>true</code>)</li>
<li><code>timeout</code>: the timeout in ms to wait for responses from other services (default <code>1000</code>)</li>
<li><code>service_fn</code>: the function the service uses to process messages (default <code>-&gt; {}</code>)</li>
</ul>
<p>the <code>service_fn</code> should respond with an object that looks like:
{
  body: {}
  status_code: 200
  headers: {}
}
This will then be sent back to the calling service.</p>
<p>The UUID of the Service is the name plus a generated UUID, this is the service instance name</p>
<p><code>transactions</code> keeps track of outgoing messages, so the service can match up sent messages to responses
and nicely stop the service by waiting for outgoing transactions to finish</p>
<p>Also, constructing the Service creates a <code>ServiceConnectionManager</code> to manage the RabbitMQ connection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  constructor: <span class="hljs-function"><span class="hljs-params">(@name, options = {})</span> -&gt;</span>
    @options = _.defaults(
      options,
      {
        amqp_uri: <span class="hljs-string">'amqp://localhost'</span>
        service_queue: <span class="hljs-literal">true</span>
        response_queue: <span class="hljs-literal">true</span>
        timeout: <span class="hljs-number">1000</span>
        service_fn:
          <span class="hljs-function"><span class="hljs-params">(message)</span> -&gt;</span> {}
      }
    )

    <span class="hljs-keyword">throw</span> <span class="hljs-string">"Service Name undefined"</span> <span class="hljs-keyword">if</span> !@name
    @uuid = <span class="hljs-string">"<span class="hljs-subst">#{@name}</span>.<span class="hljs-subst">#{Service.generateUUID()}</span>"</span>
    @transactions = {}

    <span class="hljs-keyword">if</span> @options.response_queue
      @response_queue_name = @uuid
    <span class="hljs-keyword">else</span>
      @response_queue_name = <span class="hljs-literal">null</span>

    <span class="hljs-keyword">if</span> @options.service_queue
      @service_queue_name = @name
    <span class="hljs-keyword">else</span>
      @service_queue_name = <span class="hljs-literal">null</span>

    @connection_manager = <span class="hljs-keyword">new</span> ServiceConnectionManager(
      @options.amqp_uri,
      @service_queue_name,
      @process_service_queue_message,
      @response_queue_name,
      @process_response_queue_message,
      @process_returned_message
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="life-cycle">Life Cycle</h4>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>start</code> starts the Service</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  start: <span class="hljs-function">-&gt;</span>
    @connection_manager.start()</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>stop</code> stops the service nicely by waiting for responses to outgoing messages or for them to timeout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  stop: <span class="hljs-function">-&gt;</span>
    transaction_promises = _.values(@transactions).map( <span class="hljs-function"><span class="hljs-params">(tx)</span> -&gt;</span>
      tx.promise.<span class="hljs-keyword">catch</span>( <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span>
        _log_error @uuid, <span class="hljs-string">"Stopping Transaction Error"</span>, e
      )
    )

    <span class="hljs-keyword">if</span> transaction_promises.length &gt; <span class="hljs-number">0</span>
      bb.any(transaction_promises)
      .<span class="hljs-keyword">catch</span>( <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span>
        _log_error @uuid, <span class="hljs-string">"Stopping Transaction Error"</span>, e
      )
      .<span class="hljs-keyword">finally</span>( <span class="hljs-function">=&gt;</span>
        @connection_manager.stop()
      )
    <span class="hljs-keyword">else</span>
      @connection_manager.stop()</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>kill</code> will kill the service immediately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  kill: <span class="hljs-function">-&gt;</span>
    @connection_manager.kill()</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4 id="sending-messages">Sending Messages</h4>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><code>send_message</code> sends a message to an exchange and queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  send_message: <span class="hljs-function"><span class="hljs-params">(exchange, queue, message, options)</span> -&gt;</span>
    @connection_manager.publish_message(exchange, queue, msgpack.pack(message), options)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>send_message_to_service</code> send a <code>message</code> to a service with <code>service_name</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  send_message_to_service: <span class="hljs-function"><span class="hljs-params">(service_name, message)</span> -&gt;</span>
    @send_HTTP_request_message(<span class="hljs-string">''</span>, service_name, message)</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><code>send_HTTP_request_message</code> sends a http(ish) message to an exchange and queue</p>
<p>The message is formatted in using HTTP concepts like headers, path, and body</p>
<p>The <code>x-interaction-id</code> header is used to identify a single external interaction that may involve calls to multiple services.
By following the <code>x-interaction-id</code> around the system the involved services in a single interaction can be identified
If an x-interaction-id header is present in the message’s headers we use it,
otherwise we generate one.</p>
<p>The <code>http_message_options</code> sent with the message is the:</p>
<ol>
<li><code>messageID</code> to identify the message</li>
<li><code>type</code> of <code>http_request</code> so the opposing service knows how to handle it</li>
<li><code>replyTo</code> the queue to publish the response message</li>
<li><code>contentEncoding</code> and <code>contentType</code> for encoding</li>
<li><code>expiration</code> so the message expires if the service is overloaded</li>
<li><code>mandatory</code> so the message is returned if it cannot be routed to a service</li>
</ol>
<p>The <code>response_deferred</code> deferred object promises that this message will be responded to within a time limit</p>
<p>The <code>request_promise</code> is the promise that the message is sent then responded to.
Additional information that may be useful to the service is then returned</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  send_HTTP_request_message: <span class="hljs-function"><span class="hljs-params">(exchange, queue, message)</span> -&gt;</span>
    http_message = {
      session_id:  message.session_id
      scheme:      message.protocol    || <span class="hljs-string">'http'</span>
      host:        message.hostname    || <span class="hljs-string">'localhost'</span>
      port:        message.port        || <span class="hljs-number">8080</span>
      path:        message.path        || <span class="hljs-string">"/"</span>
      query:       message.query       || {}
      verb:        message.verb        || <span class="hljs-string">"GET"</span>
      headers:     message.headers     || {}
      body:        message.body        || <span class="hljs-string">""</span>
    }

    <span class="hljs-keyword">if</span> !http_message.headers[<span class="hljs-string">'x-interaction-id'</span>]
      http_message.headers[<span class="hljs-string">'x-interaction-id'</span>] = Service.generateUUID()

    messageId = Service.generateUUID()


    http_message_options =
      messageId: messageId
      type: <span class="hljs-string">'http_request'</span>
      replyTo: @response_queue_name
      contentEncoding: <span class="hljs-string">'8bit'</span>
      contentType: <span class="hljs-string">'application/octet-stream'</span>
      expiration: @options.timeout
      mandatory: <span class="hljs-literal">true</span>

    response_deferred = {}
    @transactions[messageId] = response_deferred

    response_deferred.promise = <span class="hljs-keyword">new</span> bb( <span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> -&gt;</span>
      response_deferred.resolve_promise = resolve
      response_deferred.reject_promise = reject
    )
    .timeout(@options.timeout)
    .<span class="hljs-keyword">catch</span>(Service.TimeoutError, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> response_deferred.promise.isFulfilled()
      _log_error @uuid, <span class="hljs-string">"Timeout for message ID `<span class="hljs-subst">#{messageId}</span>`"</span>
      <span class="hljs-keyword">throw</span> err
    )
    .<span class="hljs-keyword">catch</span>(Service.MessageNotDeliveredError, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span>
      _log_error @uuid, <span class="hljs-string">"MessageNotDeliveredError for message ID `<span class="hljs-subst">#{messageId}</span>`"</span>
      <span class="hljs-keyword">throw</span> err
    )
    .<span class="hljs-keyword">finally</span>( <span class="hljs-function">=&gt;</span>
      <span class="hljs-keyword">delete</span> @transactions[messageId]
    )

    request_promise = @send_message(exchange, queue, http_message, http_message_options)
    .<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
      response_deferred.promise
    )

    request_promise.messageId = messageId
    request_promise.transactionId = http_message.headers[<span class="hljs-string">'x-interaction-id'</span>]
    request_promise.response_queue_name = @response_queue_name

    request_promise</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><code>process_response_queue_message</code> processes response messages from other the response queue</p>
<p>First it checks to see if it is a waiting transaction.
If there is no matched transactions or the message type is incorrect
it logs an error and/or rejects the transaction</p>
<p>If there is a transaction or the right type it will resolve the promise with the unpacked message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  process_response_queue_message: <span class="hljs-function"><span class="hljs-params">(msg)</span> =&gt;</span>
    deferred = @transactions[msg.properties.correlationId]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> deferred? <span class="hljs-keyword">or</span> msg.properties.type != <span class="hljs-string">'http_response'</span>
      _log_message_error(@uuid, <span class="hljs-string">"Received Unsolicited Message on Response Queue"</span>, msg)
      deferred.reject_promise(<span class="hljs-string">"Property type wrong"</span>) <span class="hljs-keyword">if</span> deferred
      <span class="hljs-keyword">return</span>
    deferred.resolve_promise(msgpack.unpack(msg.content))</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><code>process_returned_message</code> processes returned messages</p>
<p>First it checks to see if it is a waiting transaction
If there is no matched transactions it logs and returns
If a matched transaction is fond it rejects with a MessageNotDeliveredError</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  process_returned_message: <span class="hljs-function"><span class="hljs-params">(msg)</span> =&gt;</span>
    deferred = @transactions[msg?.properties?.messageId]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> deferred
      _log_message_error(@uuid, <span class="hljs-string">"Received Unsolicited Message on Return Queue"</span>, msg)
      <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">return</span> deferred.reject_promise(<span class="hljs-keyword">new</span> Service.MessageNotDeliveredError(msg?.properties?.messageId, msg?.fields?.routingKey))</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h4 id="receiving-and-responding-to-messages">Receiving and Responding To Messages</h4>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><code>process_service_queue_message</code> processes messages received on the service queue</p>
<p>If the message is type of <code>http_request</code> then pass to <code>receive_HTTP_request</code> as it expects a response,
otherwise pass to <code>receive_utility_event</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  process_service_queue_message: <span class="hljs-function"><span class="hljs-params">(msg)</span> =&gt;</span>
    type = msg.properties.type
    <span class="hljs-keyword">if</span> type == <span class="hljs-string">'http_request'</span>
      <span class="hljs-keyword">return</span> @receive_HTTP_request(msg)
    <span class="hljs-keyword">else</span>
      @receive_utility_event(msg)</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>receive_utility_event</code> receives messages of types where no response is necessary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  receive_utility_event: <span class="hljs-function"><span class="hljs-params">(msg)</span> -&gt;</span>
    type = msg.properties.type

    <span class="hljs-keyword">if</span> msg.content
      message = msgpack.unpack(msg.content)
    <span class="hljs-keyword">else</span>
      message = {}

    bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">=&gt;</span>
      @options.service_fn(message)
    ).<span class="hljs-keyword">catch</span>( <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span>
      _log_error(@uuid, <span class="hljs-string">"UTILITY_ERROR from message type <span class="hljs-subst">#{type}</span>"</span>, err)
      <span class="hljs-keyword">throw</span> err
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><code>receive_HTTP_request</code> is the message that receives the messages of type <code>http_request</code>
 and passes them to the <code>service_fn</code> to process and respond</p>
<p>First it unpacks and extracts the message properties.
Then it calls the <code>service_fn</code>, gets the result and packages it up into
HTTPish object and replies to the messaging service.
If the <code>service_fn</code> throw an error the error is logged and an
HTTPish error object with status_code 500 is sent to the messaging service.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  receive_HTTP_request: <span class="hljs-function"><span class="hljs-params">(msg)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> msg.content
      message = msgpack.unpack(msg.content)
    <span class="hljs-keyword">else</span>
      message = {body: {}, headers: {}}

    service_to_reply_to = msg.properties.replyTo
    message_replying_to = msg.properties.messageId
    this_message_id = Service.generateUUID()

    bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">=&gt;</span>
      @options.service_fn(message)
    )
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(response = {})</span> =&gt;</span>
      resp = {
        status_code:  response.status_code || <span class="hljs-number">200</span>
        headers: response.headers || { <span class="hljs-string">'x-interaction-id'</span>: message.headers[<span class="hljs-string">'x-interaction-id'</span>]}
        body: response.body || {}
      }

      @_reply_to_service_message(
        service_to_reply_to,
        resp,
        {
          type: <span class="hljs-string">'http_response'</span>,
          correlationId: message_replying_to,
          messageId: this_message_id
        }
      )
    ).<span class="hljs-keyword">catch</span>( <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span>
      _log_error(@uuid, <span class="hljs-string">"service_fn HTTP_ERROR"</span>, err)
      resp = {
        status_code: <span class="hljs-number">500</span>
        headers: {
          <span class="hljs-string">'x-interaction-id'</span>: message.headers[<span class="hljs-string">'x-interaction-id'</span>]
        }
        body: {
          code: <span class="hljs-string">'service.fault'</span>
          message: <span class="hljs-string">'An unexpected error occurred'</span>
        }
      }

      @_reply_to_service_message(
        service_to_reply_to,
        resp,
        {
          type: <span class="hljs-string">'http_response'</span>,
          correlationId: message_replying_to,
          messageId: this_message_id
        }
      )
      <span class="hljs-keyword">throw</span> err
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><code>_reply_to_service_message</code> responds to a service on its response queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _reply_to_service_message: <span class="hljs-function"><span class="hljs-params">(response_queue, message, options)</span> -&gt;</span>
    @send_message(<span class="hljs-string">''</span>, response_queue, message, options)</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="service-connection-manager">Service Connection Manager</h2>
<p>The <code>ServiceConnectionManager</code> maintains the connection to RabbitMQ and handles errors and the integration with the service.
It is <strong>state based</strong> i.e. it has a <code>state</code> that can be altered via functions and events through known paths,
and the functions can be valid only in certain states.</p>
<p>Its state diagram is:</p>
<pre><code>                 restarting
                  A      |
                 error  start()
                  |      |
     starting ---&gt; started --|
        A             |      |
      start()        stop()  |
        |             V      |
     stopped*  &lt;-  stopping  |
        |                    |
        |--------------------|
      kill()
        |
        |
        V
      killing
        |
        V
       dead
</code></pre><p>The states are <code>stopped</code>, <code>starting</code>, <code>started</code>, <code>stopping</code>, <code>restarting</code>, <code>killing</code> and <code>dead</code>.
The initial state is <code>stopped</code>, the function <code>start()</code> will move it to the state <code>starting</code> then <code>started</code>.</p>
<p>From the <code>started</code> state:</p>
<ol>
<li>an <code>error</code> can occur, causing the state becomes <code>restarting</code> then back to <code>started</code></li>
<li><code>stop()</code> can be called to move it to <code>stopping</code> then <code>stopped</code></li>
<li><code>kill()</code> can be called to move it <code>killing</code> then <code>dead</code></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceConnectionManager</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>constructor(amqp_uri, service_queue_name, service_handler, response_queue_name, response_handler, returned_handler)</code></p>
<ol>
<li><code>amqp_uri</code>           : the string URI to amqp</li>
<li><code>service_queue_name</code> : the string name of the service</li>
<li><code>service_handler</code>    : the function to process a message</li>
<li><code>response_queue_name</code>: the string response queue name</li>
<li><code>response_handler</code>   : the function to handle responses</li>
<li><code>returned_handler</code>   : the function to handle returned messages</li>
</ol>
<p>This sets the initial state to <code>stopped</code></p>
<p><code>processing_messages</code> is used to store the <code>message_id</code> to the promise of the currently processing message.
So if a <code>stop</code> is called we can wait for currently processing messages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  constructor: <span class="hljs-function"><span class="hljs-params">(@amqp_uri, @service_queue_name, @service_handler, @response_queue_name, @response_handler, @returned_handler)</span> -&gt;</span>
    @state = <span class="hljs-string">'stopped'</span>
    @processing_messages = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h4 id="life-cycle">Life Cycle</h4>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>start</code> is used to initialize the connections, channels and queues to RabbitMQ</p>
<p>This function will raise exception if state is not <code>started</code>, <code>stopped</code> or <code>restarting</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  start: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'started'</span>, <span class="hljs-string">'stopped'</span>, <span class="hljs-string">'restarting'</span>])
    <span class="hljs-keyword">return</span> bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">-&gt;</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">if</span> @state == <span class="hljs-string">'started'</span>
    @_change_state(<span class="hljs-string">'starting'</span>)
    <span class="hljs-keyword">try</span>
      @get_service_channel()
      .<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
        @_change_state(<span class="hljs-string">'started'</span>)
      )
    <span class="hljs-keyword">catch</span> error
      bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">throw</span> error)</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>stop</code> will attempt to nicely stop the service waiting for messages to stop processing</p>
<p>This function will raise exception if state is not <code>started</code> or <code>stopped</code></p>
<p>While stopping the service will stop consuming the service queue
to stop processing new messages</p>
<p>Then it will wait for all currently processing messages to finish
before closing the connection and changing the state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  stop: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'stopped'</span>, <span class="hljs-string">'started'</span>])
    <span class="hljs-keyword">return</span> bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">-&gt;</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">if</span> @state == <span class="hljs-string">'stopped'</span>

    bb.all([@get_service_channel(), @get_connection()])
    .spread( <span class="hljs-function"><span class="hljs-params">(channel, connection)</span> =&gt;</span>
      @_change_state(<span class="hljs-string">'stopping'</span>)

      <span class="hljs-keyword">if</span> @_service_queue_consumer_tag
        stop_processing = channel.cancel(@_service_queue_consumer_tag)
      <span class="hljs-keyword">else</span>
        stop_processing = bb.<span class="hljs-keyword">try</span>(<span class="hljs-function">-&gt;</span>)

      stop_processing.<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
        bb.all(_.values(@processing_messages))
      )
      .<span class="hljs-keyword">then</span>( <span class="hljs-function">-&gt;</span>
        connection.close()
      )
    )
    .<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
      @_change_state(<span class="hljs-string">'stopped'</span>)
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>restart</code> will try restart the connection and channel if an error occurs</p>
<p>This function will raise exception if state is not <code>started</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  restart: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'started'</span>])
    @_change_state(<span class="hljs-string">'restarting'</span>)
    @start()</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><code>kill</code> will immediately stop the service processing (use stop for nice shutdown)</p>
<p>This function will raise exception if state is not <code>started</code> or <code>stopped</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  kill: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'stopped'</span>,<span class="hljs-string">'started'</span>])

    @get_connection()
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(connection)</span> =&gt;</span>
      @_change_state(<span class="hljs-string">'killing'</span>)
      connection.close()
    )
    .<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
      @_change_state(<span class="hljs-string">'dead'</span>)
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><code>_assert_state</code> will raise an exception if the current state is not in <code>states</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _assert_state: <span class="hljs-function"><span class="hljs-params">(states)</span> -&gt;</span>
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> states
      <span class="hljs-keyword">if</span> @state == s
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"<span class="hljs-subst">#{@response_queue_name}</span> rejected state <span class="hljs-subst">#{@state}</span>"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><code>_change_state</code> will alter the state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _change_state: <span class="hljs-function"><span class="hljs-params">(state)</span> -&gt;</span>
    _log(@response_queue_name, <span class="hljs-string">"<span class="hljs-subst">#{@state}</span> -&gt; <span class="hljs-subst">#{state}</span>"</span>)
    @state = state</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h4 id="connection-management">Connection Management</h4>

            </div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><code>get_connection</code> returns a promise for the connection,
it creates the connection if it does not exist</p>
<p>This function will raise an exception if state is not <code>started</code> or <code>starting</code></p>
<p>It will remove the connection if it sends a <code>error</code> or <code>close</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  get_connection: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'started'</span>, <span class="hljs-string">'starting'</span>])
    <span class="hljs-keyword">return</span> @_connection <span class="hljs-keyword">if</span> @_connection

    @_connection = amqp.connect(@amqp_uri)
    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(connection)</span> =&gt;</span>
      connection.<span class="hljs-literal">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span>
        _log_error(@response_queue_name, <span class="hljs-string">"AMQP Error connection error"</span>, error)
        @_connection = <span class="hljs-literal">null</span>
      )
      connection.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">=&gt;</span>
        @_connection = <span class="hljs-literal">null</span>
      )
      connection
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><code>get_service_channel</code> returns a promise for the service channel,
it creates the channel if it does not exist</p>
<p>This function will raise exception if state is not <code>started</code> or <code>starting</code> or <code>stopping</code></p>
<p>It sets the channels <code>prefetch</code> to <code>20</code> which will retrieve 20 messages from the queue at a time.
<code>20</code> is the size recommended from
<a href="http://www.mariuszwojcik.com/2014/05/19/how-to-choose-prefetch-count-value-for-rabbitmq/">this</a> post.</p>
<p>It will pass any returned messages to the <code>returned_handler</code>.</p>
<p>If the channel has an error or closes it will clear the channel
and restart it if it is meant to be running.</p>
<p>This method also creates the queues that the service requires, the service_queue and the response_queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  get_service_channel: <span class="hljs-function">-&gt;</span>
    @_assert_state([<span class="hljs-string">'started'</span>,<span class="hljs-string">'starting'</span>,<span class="hljs-string">'stopping'</span>])
    <span class="hljs-keyword">return</span> @_service_channel <span class="hljs-keyword">if</span> @_service_channel
    @_service_channel = @get_connection()
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(connection)</span> =&gt;</span>
      connection.createChannel()
    )
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(service_channel)</span> =&gt;</span>
      service_channel.prefetch <span class="hljs-number">20</span>

      service_channel.<span class="hljs-literal">on</span>(<span class="hljs-string">'return'</span>, <span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span>
        _log(@response_queue_name, <span class="hljs-string">"Message Returned to Channel"</span>)
        @returned_handler(message)
      )

      service_channel.<span class="hljs-literal">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span>
        _log_error(@response_queue_name, <span class="hljs-string">"Service Channel Errored"</span>, error)
        @_service_channel = <span class="hljs-literal">null</span>
      )

      service_channel.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">=&gt;</span>
        @_service_channel = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">if</span> @state == <span class="hljs-string">'started'</span>
          @restart()
      )

      queue_promises = []
      <span class="hljs-keyword">if</span> @service_queue_name
        queue_promises.push @_create_service_queue(service_channel)

      <span class="hljs-keyword">if</span> @response_queue_name
        queue_promises.push @_create_response_queue(service_channel)

      bb.all(queue_promises)
      .<span class="hljs-keyword">then</span>( <span class="hljs-function">-&gt;</span> service_channel)
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4 id="queue-management">Queue Management</h4>

            </div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><code>_create_response_queue</code> takes the service channel and creates the response queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _create_response_queue: <span class="hljs-function"><span class="hljs-params">(service_channel)</span> -&gt;</span>
    service_channel.assertQueue(@response_queue_name, {expires: <span class="hljs-number">1000</span>})
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(response_queue)</span> =&gt;</span>
      service_channel.consume(@response_queue_name, @_create_response_queue_function(service_channel))
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>_create_response_queue_function</code> creates the function that consumes the response queue</p>
<p>The response queue function immediately acks the message as no other service consumes this
queue. This means if so if an error occurs in the
<code>response_handler</code> function the the message will still be removed from the queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _create_response_queue_function: <span class="hljs-function"><span class="hljs-params">(service_channel)</span> =&gt;</span>
    <span class="hljs-keyword">return</span> (msg) =&gt;
      service_channel.ack(msg)
      @response_handler(msg)</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><code>_create_service_queue</code> takes the service channel and creates the service queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _create_service_queue: <span class="hljs-function"><span class="hljs-params">(service_channel)</span> -&gt;</span>
    service_channel.assertQueue(@service_queue_name, {durable: <span class="hljs-literal">true</span>})
    .<span class="hljs-keyword">then</span>( <span class="hljs-function">=&gt;</span>
      service_channel.consume(@service_queue_name, @_create_service_queue_function(service_channel))
    )
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(ret)</span> =&gt;</span>
      @_service_queue_consumer_tag = ret.consumerTag
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p><code>_create_service_queue_function</code> creates the function that consumes the service queue</p>
<p>The service queue is where the services processing occurs.
This processing can have the potential to:</p>
<ol>
<li>succeed and return a message</li>
<li>throw an unknown error</li>
<li>throw a NAckError error</li>
<li>be killed or die while processing the message (e.g. the tin restarts)</li>
</ol>
<p>Under these conditions this function will:</p>
<ol>
<li>ack the message (happy path)</li>
<li>log an error error then ack the message</li>
<li>log the error then nack the message so it will be retried, <strong>this is very dangerous</strong> see Errors section</li>
<li>cause the service channel to die which nacks the message (so it will be retired)</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _create_service_queue_function: <span class="hljs-function"><span class="hljs-params">(service_channel)</span> -&gt;</span>
    <span class="hljs-keyword">return</span> (msg) =&gt;

      @processing_messages[msg.properties.messageId] = bb.<span class="hljs-keyword">try</span>( <span class="hljs-function">=&gt;</span> @service_handler(msg))
      .<span class="hljs-keyword">then</span>( <span class="hljs-function">-&gt;</span>
        service_channel.ack(msg)
      )
      .<span class="hljs-keyword">catch</span>(Service.NAckError, <span class="hljs-function"><span class="hljs-params">(err)</span> -&gt;</span>
        _log_error @response_queue_name, <span class="hljs-string">"NACKed MESSAGE"</span>, err
        service_channel.nack(msg)
      )
      .<span class="hljs-keyword">catch</span>( <span class="hljs-function"><span class="hljs-params">(err)</span> -&gt;</span>
        _log_error @response_queue_name,<span class="hljs-string">"Service Channel Error"</span>, err
        service_channel.ack(msg)
      )
      .<span class="hljs-keyword">finally</span>( <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">delete</span> @processing_messages[msg.properties.messageId]
      )</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h4 id="sending-messages">Sending Messages</h4>

            </div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><code>publish_message</code> publish a message to a queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  publish_message: <span class="hljs-function"><span class="hljs-params">(exchange, routing_key, message, options)</span> -&gt;</span>
    @get_service_channel()
    .<span class="hljs-keyword">then</span>( <span class="hljs-function"><span class="hljs-params">(service_channel)</span> =&gt;</span>
      service_channel.publish(exchange, routing_key, message, options)
    )</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h2 id="errors">Errors</h2>

            </div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p><strong>NAckError</strong></p>
<p>The <code>NAckError</code> can be thrown from a Service while it is processing a message to cause the message
to be put back on the service queue for processing later.</p>
<p>This is very dangerous and should be used only if necessary because if the message itself caused the
error then it will be always be put back on the queue, and cause the service to process it indefinitely.
If a message is malformed or malicious it is better for a service to swallow the message and log, rather than NAck,
however if the cuase of the error is external (e.g. a database connection error) a NAckError will let the message be processed at a more reasonable time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NAckError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span></span>
  constructor: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    @name = <span class="hljs-string">"NAckError"</span>
    @message = <span class="hljs-string">"NAck the Message"</span>
    Error.captureStackTrace(<span class="hljs-keyword">this</span>, NAckError)
Service.NAckError = NAckError</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p><strong>MessageNotDeliveredError</strong></p>
<p>The <code>MessageNotDeliveredError</code> is thrown by the service if a sent message is <a href="https://www.rabbitmq.com/semantics.html">returned</a> by RabbitMQ.
This allows a service implementation to handle if a message is sent to a service queue that does not exist.
This is like a 404 in HTTP, i.e. the service you are messaging does not exist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageNotDeliveredError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span></span>
  constructor: <span class="hljs-function"><span class="hljs-params">(messageID, routingKey)</span> -&gt;</span>
    @name = <span class="hljs-string">"MessageNotDeliveredError"</span>
    @message = <span class="hljs-string">"message <span class="hljs-subst">#{messageID}</span> not delivered to <span class="hljs-subst">#{routingKey}</span>"</span>
    Error.captureStackTrace(<span class="hljs-keyword">this</span>, MessageNotDeliveredError)
Service.MessageNotDeliveredError = MessageNotDeliveredError</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p><strong>TimeoutError</strong></p>
<p>The <code>TimeoutError</code> is thrown when a message being sent to a service takes too long.
How long it will take to timeout a message can be altered, but this means that:</p>
<ol>
<li>the service took to long to process the message</li>
<li>the service never got to process the message because it is still processing other messages</li>
<li>the service tried to process the message and errored without replying</li>
<li>the service queue exists, but no service is listening to it</li>
</ol>
<p>This error is important to handle because of under heavy load this will be the most likely error thrown.
Also, given that it can be thrown even though a message has been processed means this is another reason to ensure idempotent messages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Service.TimeoutError = bb.TimeoutError</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h2 id="logging-functions">Logging Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><code>log(uuid, message)</code> writes consistent log messages to stdout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">_log</span> = <span class="hljs-params">(uuid, message)</span> -&gt;</span>
  <span class="hljs-built_in">console</span>.log <span class="hljs-string">"<span class="hljs-subst">#{(<span class="hljs-keyword">new</span> Date()).toISOString()}</span> - <span class="hljs-subst">#{uuid}</span> - <span class="hljs-subst">#{message}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p><code>_log_error(uuid, message, error)</code> writes consistent error messages to stderr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">_log_error</span> = <span class="hljs-params">(uuid, message, error = {stack: <span class="hljs-string">''</span>})</span> -&gt;</span>
  <span class="hljs-built_in">console</span>.error <span class="hljs-string">"<span class="hljs-subst">#{(<span class="hljs-keyword">new</span> Date()).toISOString()}</span> - <span class="hljs-subst">#{uuid}</span> - <span class="hljs-subst">#{message}</span> - <span class="hljs-subst">#{error.stack}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p><code>_log_message_error(uuid, message, msg)</code> writes consistent rabbitmq msg errors to stderr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">_log_message_error</span> = <span class="hljs-params">(uuid, message, msg)</span> -&gt;</span>
  <span class="hljs-built_in">console</span>.error <span class="hljs-string">"<span class="hljs-subst">#{(<span class="hljs-keyword">new</span> Date()).toISOString()}</span> - <span class="hljs-subst">#{uuid}</span> - <span class="hljs-subst">#{message}</span> - messageID: '<span class="hljs-subst">#{msg.properties.messageId}</span>',
      correlationId: '<span class="hljs-subst">#{msg.properties.correlationId}</span>'
      type: '<span class="hljs-subst">#{msg.properties.type}</span>'
  "</span>

<span class="hljs-built_in">module</span>.exports = Service</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
